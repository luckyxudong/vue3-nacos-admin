# Vue3 网络请求的优雅封装之三：实现插件化架构和请求取消

在开发中，不知道大家会不会遇到这些需求或场景：
1）页面跳转时，之前的请求还未完成，需要取消这些请求
2）搜索框输入时，需要取消之前的搜索请求，只保留最新的
3）用户操作取消时，需要终止正在进行的请求

这些场景需要咱们的网络请求框架能支持取消请求。 咱们继续前行，为网络请求的核心封装添加**取消请求**的功能。

由于后面还要扩展一系列能力，首先咱们需要将核心层扩展为**插件化架构**，请求取消、请求防重、请求重试等，都是核心层的插件，这样代码更加模块化、可扩展！

## 1. 核心层-插件化架构

### 1.1 定义插件接口

首先，需要定义一个统一的插件接口，所有网络请求相关的功能（如取消、防重、重试等）都将作为插件，需要实现该接口。

在 `src/http/core/`目录下创建 `plugin.ts`：：

```typescript
import type { AxiosInstance } from 'axios'

/**
 * HTTP 插件接口
 * 所有网络请求相关的功能都将作为插件实现该接口
 */
export interface HttpPlugin {
  /**
   * 应用插件到 Axios 实例
   * @param instance Axios 实例
   */
  apply(instance: AxiosInstance): void
}
```

### 1.2 插件管理类

为了方便的统一管理插件，咱创建一个插件管理类，负责维护插件的注册和应用。

继续在 `src/http/core/`目录下创建 `plugin-manager.ts`：

```typescript
import type { AxiosInstance } from 'axios'
import type { HttpPlugin } from './plugin.ts'

/**
 * 插件管理器
 * 负责管理和应用 HTTP 插件
 */
export class PluginManager {
  private plugins: HttpPlugin[] = []

  /**
   * 注册插件
   * @param plugin HTTP 插件
   */
  public register(plugin: HttpPlugin): void {
    this.plugins.push(plugin)
  }

  /**
   * 应用所有插件到 Axios 实例
   * @param instance Axios 实例
   */
  public applyAll(instance: AxiosInstance): void {
    this.plugins.forEach(plugin => plugin.apply(instance))
  }

  /**
   * 清除所有插件
   */
  public clear(): void {
    this.plugins = []
  }
}
```

定义好插件的规范后，接下来便可以开始实现取消请求这个插件了。

## 2. 取消请求

Axios 支持取消请求：在 v0.22.0 之前，使用 `CancelToken`，但之后的版本已弃用该 API，而是使用 `AbortController`方式来实现取消：

https://axios-http.com/zh/docs/cancellation

咱们版本为 1.13.2，使用 `AbortController`来实现取消请求的功能。AbortController 是浏览器原生 API，用于取消网络请求等异步操作，是处理请求取消的标准方案。具体信息大家移步官网：

https://developer.mozilla.org/en-US/docs/Web/API/AbortController

创建 AbortController 的实例对象后，可获取 `signal`属性，调用该对象的 abort() 方法，会触发取消请求操作，使关联的 signal 进入已取消状态。

### 2.1 实现 RequestCanceler 插件

在 `src/http/core/`目录下创建 `request-canceler.ts`，该文件中创建一个类 `RequestCanceler`，实现前面定义的 `HttpPlugin`接口。

实现请求取消的核心逻辑：
1）**定义一个 Map**，用来存储**请求的配置**与**取消控制器对象**的映射关系：key 为请求配置按照某个规则得到的字符串，value 即为这个请求对应的取消控制器。
2）发送请求前，在**请求拦截器**中创建取消控制器对象，并将该对象的 signal 设置到请求配置 config 中，同时将 config 与该对象添加到 Map 中。
3）在**响应拦截器**中（无论成功还是失败），都需要根据请求配置 config 从 Map 中移除。
4）如果需要**取消某个请求**，则从 Map 中根据请求配置获取取消控制器，调用该控制器的 abort() 方法；
5）如果需要**取消所有请求**，则遍历 Map 中的所有控制器，依次调用 abort() 方法。

```typescript
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios'
import type { HttpPlugin } from './plugin.ts'

/**
 * 请求取消器插件
 * 负责管理和取消请求
 */
export class RequestCanceler implements HttpPlugin {
  // 存储取消器的映射表
  private cancelMap: Map<string, AbortController>

  constructor() {
    this.cancelMap = new Map()
  }

  /**
   * 生成请求的唯一标识
   */
  private generateKey(config: AxiosRequestConfig): string {
    const { url, method, params, data } = config
    return `${method || 'GET'}-${url}-${JSON.stringify(params || {})}-${JSON.stringify(data || {})}`
  }

  /**
   * 添加请求到取消器映射表
   * @param config 请求配置
   */
  public add(config: AxiosRequestConfig): void {
    // 先取消之前相同的请求
    this.remove(config)
    
    const key = this.generateKey(config)
    const controller = new AbortController()
    
    config.signal = controller.signal
    this.cancelMap.set(key, controller)
  }

  /**
   * 取消请求并从映射表中移除
   */
  public remove(config: AxiosRequestConfig): void {
    const key = this.generateKey(config)
    if (this.cancelMap.has(key)) {
      const controller = this.cancelMap.get(key)
      controller?.abort()
      this.cancelMap.delete(key)
    }
  }

  /**
   * 取消所有请求
   */
  public clear(): void {
    this.cancelMap.forEach((controller) => {
      controller.abort()
    })
    this.cancelMap.clear()
  }

  /**
   * 应用插件到 Axios 实例
   * @param instance Axios 实例
   */
  public apply(instance: AxiosInstance): void {
    // 请求拦截器：添加请求到取消器
    instance.interceptors.request.use(
      (config: AxiosRequestConfig) => {
        this.add(config)
        return config as any
      },
      (error: AxiosError) => {
        return Promise.reject(error)
      }
    )

    // 响应拦截器：从取消器中移除请求
    instance.interceptors.response.use(
      (response: AxiosResponse) => {
        this.remove(response.config)
        return response
      },
      (error: AxiosError) => {
        if (error.config) {
          this.remove(error.config)
        }
        return Promise.reject(error)
      }
    )
  }
}
```

### 2.2 在 HttpClient 中集成 RequestCanceler 插件

实现了请求取消插件，接下来需要将该插件集成到`HttpClient`中。

可能在某些项目中不需要取消请求这一功能，咱可以在前面定义的 HTTP 请求客户端配置 HttpClientConfig 中添加一个配置项 **enableCancel** 来配置是否开启取消请求功能。

`src/http/core/types.ts`：
扩展 `HttpClientConfig`配置属性：

```typescript
/**
 * HTTP请求客户端配置
 */
export interface HttpClientConfig {
  baseURL?: string
  timeout?: number
  headers?: Record<string, string>
  interceptor?: InterceptorConfig
  
  // 新增配置项
  enableCancel?: boolean // 是否开启请求取消
}
```

接着修改 HttpClient 类，使用 `PluginManager`来管理和应用插件：
`src/http/core/http-client.ts`：

```typescript
// ... 其他导入
import { RequestCanceler } from './request-canceler.ts'
import { PluginManager } from './plugin-manager.ts'

// 默认配置
const defaultConfig: HttpClientConfig = {
  // ...
  enableCancel: true,
}

export class HttpClient {
  // ... 其他属性
  private pluginManager: PluginManager
  private requestCanceler: RequestCanceler

  constructor(config: HttpClientConfig = {}) {
    // ...

    this.pluginManager = new PluginManager()
    this.requestCanceler = new RequestCanceler()

    this.registerPlugins()
    this.setInterceptors()
  }

  private registerPlugins() {
    // 根据配置注册插件
    if (this.config.cancelable) {
      this.pluginManager.register(this.requestCanceler)
    }
    
    // 应用所有插件
    this.pluginManager.applyAll(this.instance)
  }

  // ... 其他方法

  /**
   * 取消所有请求
   */
  public cancelAll(): void {
    this.requestCanceler.clear()
  }

  /**
   * 获取插件管理器
   * 便于后续动态添加或移除插件
   */
  public getPluginManager(): PluginManager {
    return this.pluginManager
  }
}
```

这样，咱就通过插件化架构在 `HttpClient`中集成了第一个插件 `RequestCanceler`：
当请求发起时，会自动添加到取消器中；
当请求完成或失败时，会自动从取消器中移除。

### 2.3 测试取消请求

修改 `src/pages/http-demo.vue`文件，添加测试取消全部请求的功能：

```vue
<template>
  <div>
    <!-- 其他内容不变 -->
    
    <!-- 测试按钮 -->
    <div class="mt-4">
      <button @click="onTestCancelAllRequests" class="ml-2">测试取消全部请求</button>
    </div>
  </div>
</template>

<script setup lang="ts">
// ...
import { api } from '@/http'

// 测试取消全部请求
const onTestCancelAllRequests = async () => {
  console.log('开始测试取消全部请求')

  // 发送多个请求
  for (let i = 0; i < 3; i++) {
    fetchData({ pageNum: i + 1 })
  }

  // 1秒后取消所有请求
  setTimeout(() => {
    console.log('取消全部请求')
    api.cancelAll()
  }, 1000)
}
</script>
```

启动服务，当点击测试按钮时，在浏览器中可以看到发出了 3 个分页请求，1秒后所有请求会被取消，并且控制台会输出 "取消全部请求"。

## 小结

首先实现了网络请求的插件化架构，接着又简单介绍了取消请求的实现方案，最后实现了取消请求插件，并添加到 HttpClient 中，在该类中通过配置决定是否开启取消请求功能。


























